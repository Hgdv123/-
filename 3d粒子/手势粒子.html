<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>å…¨æ¯ç²’å­æ‰‹åŠ¿äº¤äº’ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* å®¹å™¨å¸ƒå±€ */
        #canvas-container { width: 100vw; height: 100vh; position: absolute; z-index: 1; }
        
        /* æ‘„åƒå¤´ç”»ä¸­ç”» */
        #video-wrapper {
            position: absolute; bottom: 20px; left: 20px; z-index: 10;
            width: 200px; height: 150px;
            border-radius: 12px; overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            background: #000;
            transition: opacity 0.3s;
        }
        #video-element { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.8; }
        
        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        #status-bar {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            width: 100%; text-align: center; pointer-events: none;
            z-index: 5;
        }
        .pill {
            display: inline-block;
            background: rgba(10,10,10,0.8); color: #00ffcc;
            padding: 6px 20px; border-radius: 30px;
            font-size: 13px; letter-spacing: 1px;
            border: 1px solid rgba(0,255,200,0.3);
            backdrop-filter: blur(5px);
        }

        /* åŠ è½½åŠ¨ç”» */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 16px; letter-spacing: 2px;
            text-transform: uppercase; z-index: 20;
            pointer-events: none; transition: opacity 0.5s;
        }

        /* å…¨å±æŒ‰é’® */
        #fs-btn {
            position: absolute; top: 20px; right: 20px;
            background: transparent; border: 1px solid rgba(255,255,255,0.3);
            color: white; padding: 8px 15px; border-radius: 4px;
            cursor: pointer; z-index: 15; font-size: 12px;
            transition: all 0.3s;
        }
        #fs-btn:hover { background: rgba(255,255,255,0.1); border-color: white; }

        /* GUIè°ƒæ•´ */
        .lil-gui { --background-color: rgba(10, 10, 10, 0.85); --text-color: #eee; }
    </style>

    <!-- æ ¸å¿ƒåº“ -->
    <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>
    <script src="https://unpkg.com/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>
    <!-- AI è§†è§‰åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨åˆå§‹åŒ–å…¨æ¯å¼•æ“...</div>
    
    <div id="video-wrapper">
        <video id="video-element" playsinline></video>
    </div>

    <div id="status-bar">
        <div class="pill" id="status-text">ç­‰å¾…æ‰‹åŠ¿æ¥å…¥...</div>
    </div>

    <button id="fs-btn">â›¶ å…¨å±æ¨¡å¼</button>
    <div id="canvas-container"></div>

<script>
    // ================= é…ç½®å‚æ•° =================
    const CONFIG = {
        count: 25000,           // ç²’å­æ€»æ•°
        particleSize: 0.5,      // ç²’å­å¤§å°
        model: 'Heart',         // åˆå§‹æ¨¡å‹
        globalColor: '#ffffff', // å…¨å±€è‰²è°ƒæ··åˆ
        mixRatio: 0.2,          // å…¨å±€è‰²æ··åˆå¼ºåº¦
        interactionSmooth: 0.1, // æ‰‹åŠ¿å¹³æ»‘åº¦
        noiseSpeed: 0.5,        // ç²’å­æµ®åŠ¨é€Ÿåº¦
        autoRotate: true        // æ— æ‰‹åŠ¿æ—¶è‡ªåŠ¨æ—‹è½¬
    };

    // ================= å…¨å±€å˜é‡ =================
    let scene, camera, renderer, particleSystem;
    let originalPositions = []; // æ¨¡å‹åŸå§‹åæ ‡
    let targetPositions = [];   // å˜æ¢åçš„ç›®æ ‡åæ ‡
    let originalColors = [];    // æ¨¡å‹åŸå§‹é¢œè‰²
    let time = 0;

    // æ‰‹åŠ¿çŠ¶æ€
    let handState = {
        detected: false,
        scale: 1.0,         // å¼ åˆæ§åˆ¶ç¼©æ”¾
        rotationX: 0,       // æ‰‹æŒæ°´å¹³ä½ç½® -> Yè½´æ—‹è½¬
        rotationZ: 0,       // æ‰‹æŒå€¾æ–œ -> Zè½´æ—‹è½¬
        centerX: 0,
        centerY: 0
    };
    // å¹³æ»‘åçš„æ‰‹åŠ¿æ•°æ®
    let smoothHand = { scale: 1.0, rotX: 0, rotZ: 0 };

    // ================= 1. å›¾å½¢å¼•æ“ (Three.js) =================
    function initThree() {
        const container = document.getElementById('canvas-container');
        
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 35;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        createParticles();
        window.addEventListener('resize', onResize);
    }

    // åˆ›å»ºç²’å­ç³»ç»Ÿ
    function createParticles() {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.count * 3);
        const colors = new Float32Array(CONFIG.count * 3);
        const sizes = new Float32Array(CONFIG.count);
        const randoms = new Float32Array(CONFIG.count); // ç”¨äºå™ªç‚¹è¿åŠ¨

        const colorObj = new THREE.Color();

        for (let i = 0; i < CONFIG.count; i++) {
            // åˆå§‹éšæœºæ•£å¸ƒ
            positions[i * 3] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            
            // åˆå§‹é¢œè‰²
            colorObj.setHSL(Math.random(), 0.8, 0.5);
            colors[i * 3] = colorObj.r;
            colors[i * 3 + 1] = colorObj.g;
            colors[i * 3 + 2] = colorObj.b;

            sizes[i] = Math.random();
            randoms[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('random', new THREE.BufferAttribute(randoms, 1));

        // ç”Ÿæˆé«˜å…‰è´´å›¾
        const sprite = getSprite();

        const material = new THREE.PointsMaterial({
            size: CONFIG.particleSize,
            map: sprite,
            vertexColors: true, // å¯ç”¨é¡¶ç‚¹é¢œè‰²
            blending: THREE.AdditiveBlending, // å åŠ å‘å…‰æ¨¡å¼
            depthWrite: false,
            transparent: true,
            opacity: 0.9,
            sizeAttenuation: true
        });

        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // åˆå§‹åŒ–ç¼“å­˜æ•°ç»„
        targetPositions = new Float32Array(positions);
        updateModel(CONFIG.model);
    }

    // åŠ¨æ€ç”Ÿæˆå‘å…‰çº¹ç†
    function getSprite() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(0.2, 'rgba(255,255,255,0.5)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 32, 32);
        return new THREE.CanvasTexture(canvas);
    }

    // ================= 2. æ¨¡å‹ç”Ÿæˆç®—æ³• =================
    const MODELS = {
        'Heart': (i, count) => {
            const t = Math.random() * Math.PI * 2;
            const y_factor = Math.random();
            // 3Dçˆ±å¿ƒå…¬å¼
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            const scale = (0.5 + Math.random()*0.5) * 0.8; 
            
            // å¢åŠ åšåº¦
            const z = (Math.random() - 0.5) * 6;
            
            // é¢œè‰²ï¼šä¸­å¿ƒç™½ -> è¾¹ç¼˜ç²‰çº¢
            const dist = Math.sqrt(x*x + y*y);
            const color = new THREE.Color().setHSL(0.95, 0.9, 0.8 - dist/20);
            
            return { pos: [x*scale, y*scale, z], col: color };
        },
        'Flower': (i, count) => {
            // ç«ç‘°çº¿å˜ä½“
            const k = 5; // èŠ±ç“£æ•°
            const theta = Math.random() * Math.PI * 2;
            const r = Math.sin(k * theta) * 10 + 5 + Math.random()*3;
            const phi = (Math.random()-0.5) * Math.PI * 0.5; // èŠ±ç“£å¼¯æ›²åº¦

            const x = r * Math.cos(theta) * Math.cos(phi);
            const y = r * Math.sin(theta) * Math.cos(phi);
            const z = r * Math.sin(phi) * 1.5;

            const color = new THREE.Color().setHSL(0.8 + r/30, 0.8, 0.6);
            return { pos: [x, y, z], col: color };
        },
        'Saturn': (i, count) => {
            const isRing = i > count * 0.3; // 70%æ˜¯æ˜Ÿç¯
            let x, y, z, color;
            
            if (!isRing) {
                // æ˜Ÿä½“
                const r = 6;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
                color = new THREE.Color().setHSL(0.1, 0.8, 0.6); // é‡‘é»„è‰²
            } else {
                // æ˜Ÿç¯
                const angle = Math.random() * Math.PI * 2;
                const dist = 9 + Math.random() * 8;
                x = Math.cos(angle) * dist;
                z = Math.sin(angle) * dist;
                y = (Math.random()-0.5) * 0.5;
                // é¢œè‰²æ¸å˜
                color = new THREE.Color().setHSL(0.6 + dist/40, 0.6, 0.7);
            }
            return { pos: [x, y, z], col: color };
        },
        'Buddha': (i, count) => {
            // ç¨‹åºåŒ–ç”Ÿæˆæ‰“åè½®å»“ (çƒä½“å †å )
            const r = Math.random();
            let x, y, z;
            
            if (r < 0.2) { // å¤´
                const rad = 2.5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                x = rad * Math.sin(phi) * Math.cos(theta);
                y = rad * Math.sin(phi) * Math.sin(theta) + 5.5;
                z = rad * Math.cos(phi);
            } else if (r < 0.55) { // èº¯å¹²
                const rad = 4.0;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                x = rad * Math.sin(phi) * Math.cos(theta);
                y = rad * Math.sin(phi) * Math.sin(theta) * 1.2; // ç¨å¾®æ‹‰é•¿
                z = rad * Math.cos(phi);
            } else { // ç›˜è…¿åº•åº§ (æ‰æ¤­çƒ)
                const rad = 6.5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                x = rad * Math.sin(phi) * Math.cos(theta);
                y = (rad * Math.sin(phi) * Math.sin(theta)) * 0.4 - 3.5; // å‹æ‰å¹¶ä¸‹ç§»
                z = rad * Math.cos(phi) * 0.8; // Zè½´ä¹Ÿå‹ä¸€ç‚¹
            }
            const color = new THREE.Color().setHSL(0.12, 0.9, 0.6 + y/15); // é‡‘èº«
            return { pos: [x, y, z], col: color };
        },
        'Fireworks': (i, count) => {
            const r = Math.random() * 25;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            
            // çƒŸèŠ±å¤šå½©
            const hue = Math.random();
            const color = new THREE.Color().setHSL(hue, 1.0, 0.7);
            return { pos: [x, y, z], col: color };
        }
    };

    function updateModel(type) {
        if (!particleSystem) return;
        const generator = MODELS[type];
        
        // ä¸´æ—¶æ•°ç»„
        const newPos = new Float32Array(CONFIG.count * 3);
        const newCol = new Float32Array(CONFIG.count * 3);

        for(let i=0; i<CONFIG.count; i++) {
            const res = generator(i, CONFIG.count);
            newPos[i*3] = res.pos[0];
            newPos[i*3+1] = res.pos[1];
            newPos[i*3+2] = res.pos[2];
            
            newCol[i*3] = res.col.r;
            newCol[i*3+1] = res.col.g;
            newCol[i*3+2] = res.col.b;
        }

        originalPositions = newPos; // å­˜å‚¨ç›®æ ‡å½¢æ€çš„åŸå§‹åæ ‡(æœªæ—‹è½¬ç¼©æ”¾)
        originalColors = newCol;    // å­˜å‚¨åŸå§‹é¢œè‰²
        
        // é¢œè‰²ç«‹å³åº”ç”¨(å¸¦æ··åˆ)ï¼Œä½ç½®åœ¨animateä¸­æ’å€¼
        const colorsAttr = particleSystem.geometry.attributes.color;
        
        // æ··åˆç”¨æˆ·é€‰æ‹©çš„é¢œè‰²
        const userColor = new THREE.Color(CONFIG.globalColor);
        for(let i=0; i<CONFIG.count; i++) {
            const r = originalColors[i*3];
            const g = originalColors[i*3+1];
            const b = originalColors[i*3+2];
            
            // ç®€å•çš„RGB lerpæ··åˆ
            colorsAttr.setXYZ(i, 
                r * (1-CONFIG.mixRatio) + userColor.r * CONFIG.mixRatio,
                g * (1-CONFIG.mixRatio) + userColor.g * CONFIG.mixRatio,
                b * (1-CONFIG.mixRatio) + userColor.b * CONFIG.mixRatio
            );
        }
        colorsAttr.needsUpdate = true;
    }
    
    // é¢œè‰²æ›´æ–°è¾…åŠ©
    function refreshColor() {
        if(!originalColors.length) return;
        const colorsAttr = particleSystem.geometry.attributes.color;
        const userColor = new THREE.Color(CONFIG.globalColor);
        
        for(let i=0; i<CONFIG.count; i++) {
            colorsAttr.setXYZ(i, 
                originalColors[i*3] * (1-CONFIG.mixRatio) + userColor.r * CONFIG.mixRatio,
                originalColors[i*3+1] * (1-CONFIG.mixRatio) + userColor.g * CONFIG.mixRatio,
                originalColors[i*3+2] * (1-CONFIG.mixRatio) + userColor.b * CONFIG.mixRatio
            );
        }
        colorsAttr.needsUpdate = true;
    }

    // ================= 3. æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ (æ ¸å¿ƒ) =================
    function setupMediaPipe() {
        const videoElement = document.getElementById('video-element');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

        hands.setOptions({
            maxNumHands: 1, // ä¸“æ³¨å•æ‰‹æ§åˆ¶
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        hands.onResults(results => {
            if (results.multiHandLandmarks.length > 0) {
                handState.detected = true;
                const lm = results.multiHandLandmarks[0];

                // --- A. è®¡ç®—å¼ å¼€åº¦ (ç¼©æ”¾) ---
                // æ¯”è¾ƒæŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦» ä¸ æ‰‹æŒåŸºå‡†é•¿åº¦
                const wrist = lm[0];
                const middleTip = lm[12];
                const middleBase = lm[9]; // ä¸­æŒ‡æ ¹éƒ¨
                
                const palmLen = Math.hypot(middleBase.x - wrist.x, middleBase.y - wrist.y);
                const fingerLen = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y);
                
                // æ¯”ç‡ > 1.8 è®¤ä¸ºæ˜¯å¼ å¼€ï¼Œ< 1.0 è®¤ä¸ºæ˜¯æ¡æ‹³
                const ratio = fingerLen / palmLen;
                // æ˜ å°„åˆ° 0.2 (æœ€å°) ~ 2.0 (æœ€å¤§)
                let targetScale = (ratio - 0.8) * 1.5;
                targetScale = Math.max(0.1, Math.min(2.5, targetScale));
                
                handState.scale = targetScale;

                // --- B. è®¡ç®—æ—‹è½¬ (æ ¸å¿ƒæ–°åŠŸèƒ½) ---
                // 1. æ°´å¹³å¹³ç§»æ—‹è½¬ (Pan): æ‰‹åœ¨å±å¹•å·¦è¾¹ï¼Œæ¨¡å‹å‘å·¦è½¬ï¼›åœ¨å³è¾¹å‘å³è½¬
                // xåæ ‡ 0(å·¦) ~ 1(å³). 0.5ä¸ºä¸­å¿ƒ
                handState.rotationX = (lm[9].x - 0.5) * 3; // æ”¾å¤§ç³»æ•°ï¼Œå¢åŠ çµæ•åº¦

                // 2. å€¾æ–œæ—‹è½¬ (Roll): æ‰‹è…•è½¬åŠ¨
                // è®¡ç®—æ‰‹è…•(0)åˆ°ä¸­æŒ‡æ ¹(9)å‘é‡çš„è§’åº¦ï¼Œæˆ–è€…å°æŒ‡æ ¹(17)åˆ°é£ŸæŒ‡æ ¹(5)çš„å‘é‡
                const p1 = lm[17]; // å°æŒ‡æ ¹
                const p2 = lm[5];  // é£ŸæŒ‡æ ¹
                // è®¡ç®—è§’åº¦ (atan2è¿”å›å¼§åº¦)
                const angle = Math.atan2(p1.y - p2.y, p1.x - p2.x);
                // ä¿®æ­£åŸºå‡†ï¼Œä½¿å¹³æ”¾æ—¶æ¥è¿‘0
                handState.rotationZ = -(angle + Math.PI/2); // è´Ÿå·å› ä¸ºYè½´åå‘

                // UI åé¦ˆ
                const isOpen = ratio > 1.4;
                document.getElementById('status-text').innerText = 
                    `å·²è¿æ¥ | ${isOpen ? 'ğŸ– å¼ å¼€(æ‰©æ•£)' : 'âœŠ æ¡æ‹³(æ”¶ç¼©)'} | â†” æ—‹è½¬`;
                document.getElementById('status-text').style.color = '#00ffcc';

            } else {
                handState.detected = false;
                document.getElementById('status-text').innerText = "ç­‰å¾…æ‰‹åŠ¿æ¥å…¥...";
                document.getElementById('status-text').style.color = '#aaa';
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => await hands.send({image: videoElement}),
            width: 320, height: 240
        });
        
        cameraUtils.start().then(() => {
            document.getElementById('loading').style.opacity = 0;
        });
    }

    // ================= 4. åŠ¨ç”»å¾ªç¯ =================
    function animate() {
        requestAnimationFrame(animate);
        time += 0.015;

        if (!particleSystem) return;

        // å¹³æ»‘å¤„ç†æ‰‹åŠ¿æ•°æ®
        if (handState.detected) {
            // Lerp æ’å€¼ï¼šè®©åŠ¨ä½œæ›´è·Ÿæ‰‹ï¼Œä½†æœ‰æƒ¯æ€§
            smoothHand.scale += (handState.scale - smoothHand.scale) * CONFIG.interactionSmooth;
            smoothHand.rotX += (handState.rotationX - smoothHand.rotX) * CONFIG.interactionSmooth;
            smoothHand.rotZ += (handState.rotationZ - smoothHand.rotZ) * CONFIG.interactionSmooth;
        } else {
            // æ— æ‰‹åŠ¿æ—¶ï¼Œå‘¼å¸æ•ˆæœ + è‡ªåŠ¨æ—‹è½¬
            smoothHand.scale += (1.0 + Math.sin(time)*0.1 - smoothHand.scale) * 0.05;
            if(CONFIG.autoRotate) {
                smoothHand.rotX += 0.005; // æŒç»­è‡ªè½¬
            }
            smoothHand.rotZ *= 0.95; // å½’é›¶å€¾æ–œ
        }

        const positions = particleSystem.geometry.attributes.position.array;
        const randoms = particleSystem.geometry.attributes.random.array;
        
        // é¢„è®¡ç®—æ—‹è½¬çŸ©é˜µ (åŸºäºæ‰‹åŠ¿)
        // é¡ºåºï¼šå…ˆåº”ç”¨æ¨¡å‹åŸå§‹åæ ‡ -> ç¼©æ”¾ -> ç»•Yè½´æ—‹è½¬(Pan) -> ç»•Zè½´æ—‹è½¬(Roll)
        const cosY = Math.cos(smoothHand.rotX);
        const sinY = Math.sin(smoothHand.rotX);
        const cosZ = Math.cos(smoothHand.rotZ);
        const sinZ = Math.sin(smoothHand.rotZ);

        for (let i = 0; i < CONFIG.count; i++) {
            const i3 = i * 3;
            
            // 1. è·å–åŸå§‹ç›®æ ‡ä½ç½®
            let x = originalPositions[i3];
            let y = originalPositions[i3+1];
            let z = originalPositions[i3+2];

            // 2. åº”ç”¨ç¼©æ”¾ (æ‰‹æŒå¼ åˆ)
            x *= smoothHand.scale;
            y *= smoothHand.scale;
            z *= smoothHand.scale;

            // 3. æ·»åŠ åŠ¨æ€å™ªç‚¹ (å‘¼å¸/æ¼‚æµ®æ„Ÿ)
            const noise = Math.sin(time * CONFIG.noiseSpeed + randoms[i] * 10) * 0.2 * smoothHand.scale;
            x += noise;
            y += Math.cos(time * CONFIG.noiseSpeed + randoms[i] * 10) * 0.2 * smoothHand.scale;
            z += noise;

            // 4. æ‰‹åŠ¨æ—‹è½¬çŸ©é˜µå˜æ¢
            // Yè½´æ—‹è½¬ (å·¦å³è½¬)
            let tx = x * cosY - z * sinY;
            let tz = x * sinY + z * cosY;
            let ty = y;

            // Zè½´æ—‹è½¬ (ä¾§å€¾)
            let finalX = tx * cosZ - ty * sinZ;
            let finalY = tx * sinZ + ty * cosZ;
            let finalZ = tz;

            // 5. æ›´æ–°ä½ç½® (Lerpåˆ°è®¡ç®—å‡ºçš„æ–°ä½ç½®ï¼Œå¢åŠ æ‹–å°¾å¹³æ»‘æ„Ÿ)
            positions[i3]     += (finalX - positions[i3]) * 0.2;
            positions[i3 + 1] += (finalY - positions[i3 + 1]) * 0.2;
            positions[i3 + 2] += (finalZ - positions[i3 + 2]) * 0.2;
        }

        particleSystem.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ================= 5. UI åˆå§‹åŒ– =================
    function initGUI() {
        const gui = new lil.GUI({ title: 'æ§åˆ¶å°' });
        
        gui.add(CONFIG, 'model', Object.keys(MODELS)).name('âœ¨ æ¨¡å‹é€‰æ‹©').onChange(updateModel);
        
        gui.addColor(CONFIG, 'globalColor').name('ğŸ¨ ç²’å­æŸ“è‰²').onChange(refreshColor);
        gui.add(CONFIG, 'mixRatio', 0, 1).name('æŸ“è‰²å¼ºåº¦').onChange(refreshColor);
        
        gui.add(CONFIG, 'particleSize', 0.1, 2.0).name('ç²’å­å¤§å°').onChange(v => {
            if(particleSystem) particleSystem.material.size = v;
        });
        
        gui.add(CONFIG, 'autoRotate').name('è‡ªåŠ¨æ¼”ç¤ºæ¨¡å¼');
        
        const folder = gui.addFolder('é«˜çº§è®¾ç½®');
        folder.add(CONFIG, 'interactionSmooth', 0.01, 0.5).name('è·Ÿæ‰‹çµæ•åº¦');
        folder.add(CONFIG, 'noiseSpeed', 0, 2).name('æ‰°åŠ¨é€Ÿåº¦');
    }

    // å…¨å±æŒ‰é’®
    document.getElementById('fs-btn').addEventListener('click', () => {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
            document.getElementById('fs-btn').innerText = "é€€å‡ºå…¨å±";
        } else {
            document.exitFullscreen();
            document.getElementById('fs-btn').innerText = "â›¶ å…¨å±æ¨¡å¼";
        }
    });

    // å¯åŠ¨
    initThree();
    initGUI();
    setupMediaPipe();
    animate();

</script>
</body>
</html>
